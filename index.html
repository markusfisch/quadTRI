<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<title>quadTRI</title>
<style type="text/css">

body
{
	margin: 0; padding: 0;
	overflow: hidden;
	background: #f0f0f0;
}

canvas
{
	-webkit-transform: scale3d( 1, 1, 1 );
}

</style>
</head>
<body>
<script>

"use strict";

var Game = Game || {};

;!function( g )
{
	var canvas = null,
		ctx,
		width,
		height,
		horizon,
		normalMag,
		quadCols = 3,
		quadRows = 3,
		triangles = [],
		trianglesLength,
		trianglesPerRow,
		trianglesMod,
		players = [],
		activePlayer = 0,
		hover,
		fine = false;

	function highlight( idx, color, player )
	{
		if( hover != idx )
			return color;

		if( player > -1 )
			return players[player].highlight;

		return "#bbb";
	}

	function draw( time )
	{
		if( fine )
			return;

		var n;

		ctx.clearRect( 0, 0, width, height );

		for( n = 2; n--; )
		{
			var p = players[n],
				d = p.display;

			ctx.globalAlpha = n == activePlayer ? 1 : .25;
			ctx.drawImage(
				d.image,
				d.left,
				d.top );
		}

		ctx.globalAlpha = 1;

		for( n = trianglesLength; n--; )
		{
			var t = triangles[n],
				v = t.vertices;

			if( v[0] > horizon ||
				v[1] > horizon ||
				v[0] < -horizon ||
				v[1] < -horizon )
				continue;

			var p = t.player,
				m = t.move,
				cos = p < 0 ? Math.cos( n+time )*normalMag : 0,
				sin = p < 0 ? Math.sin( n+time )*normalMag : 0;

			if( m != null )
			{
				var x = m[0]*time,
					y = m[1]*time;

				v[0] += x;
				v[2] += x;
				v[4] += x;

				v[1] += y;
				v[3] += y;
				v[5] += y;
			}

			ctx.fillStyle = highlight( n, t.color, p );
			ctx.beginPath();
			ctx.moveTo( v[0]+cos, v[1]+sin );
			ctx.lineTo( v[2]+sin, v[3]+cos );
			ctx.lineTo( v[4]+cos, v[5]+sin );
			ctx.closePath();
			ctx.fill();

			/*var w = ctx.measureText( n );
			ctx.fillStyle = "#111";
			ctx.fillText(
				n,
				(v[0]+v[2]+v[4])/3-w.width/2,
				(v[1]+v[3]+v[5])/3 );*/
		}
	}

	function run()
	{
		var time = new Date().getTime()*.002;

		draw( time );
		requestAnimFrame( run );
	}

	function posToTriangle( p )
	{
		var n,
			x = p.x,
			y = p.y;

		for( n = trianglesLength; n--; )
		{
			var v = triangles[n].vertices,
				a = { x: v[0], y: v[1] },
				b = { x: v[2], y: v[3] },
				c = { x: v[4], y: v[5] },
				xa = x-a.x,
				ya = y-a.y,
				ps = (b.x-a.x)*ya-(b.y-a.y)*xa > 0;

			if( (c.x-a.x)*ya-(c.y-a.y)*xa > 0 == ps ||
				(c.x-b.x)*(y-b.y)-(c.y-b.y)*(x-b.x) > 0 != ps )
				continue;

			return n;
		}

		return -1;
	}

	function posFromEvent( ev )
	{
		var x,
			y;

		if( ev.touches )
		{
			var t = ev.touches[0];

			x = t.pageX;
			y = t.pageY;
		}
		else if( window.opera )
		{
			x = event.clientX;
			y = event.clientY;
		}
		else if( document.all )
		{
			if( document.documentElement &&
				document.documentElement.scrollTop )
			{
				x = event.clientX+document.documentElement.scrollLeft;
				y = event.clientY+document.documentElement.scrollTop;
			}
			else
			{
				x = event.clientX+document.body.scrollLeft;
				y = event.clientY+document.body.scrollTop;
			}
		}
		else
		{
			x = ev.pageX;
			y = ev.pageY;
		}

		return { x: x, y: y }
	}

	function scoreTriangle( idx )
	{
		var t = triangles[idx];

		t.scored = true;
		t.move = [0, .00000001];
	}

	function canScoreSmallQuad( idx, player, complete )
	{
		var triInCell = idx-(idx >> 2 << 2),
			yan = idx;

		if( idx & 1 )
		{
			var lastInRow = trianglesLength-1;

			yan += triInCell == 1 ? -trianglesMod : trianglesMod;

			if( yan < 0 )
				yan += trianglesLength;
			else if( yan > lastInRow )
				yan -= trianglesLength;
		}
		else
		{
			var firstInCol =
					Math.floor( idx / trianglesPerRow )*
					trianglesPerRow,
				lastInCol = firstInCol+trianglesMod;

			yan += triInCell == 0 ? -2 : 2;

			if( yan < firstInCol )
				yan = lastInCol;
			else if( yan > lastInCol )
				yan = firstInCol;
		}

		if( triangles[yan].scored )
			return -1;

		var p = triangles[yan].player;
		return p == player || (!complete && p < 0) ? yan : -1;
	}

	function scoreSmallQuad( idx, player )
	{
		var yan = canScoreSmallQuad( idx, player, true );

		if( yan < 0 )
			return;

		players[player].update( 1 );

		scoreTriangle( idx );
		scoreTriangle( yan );
	}

	function canScoreBigQuad( idx, player, complete )
	{
		var from = idx >> 2 << 2,
			to = from+4,
			n;

		for( n = from; n < to; ++n )
		{
			if( triangles[n].scored )
				return -1;

			var p = triangles[n].player;

			if( complete )
			{
				if( p != player )
					return -1;
			}
			else
			{
				if( p > -1 && p != player )
					return -1;
			}
		}

		return from;
	}

	function scoreBigQuad( idx, player )
	{
		var from = canScoreBigQuad( idx, player, true );

		if( from < 0 )
			return;

		var to = from+4,
			n;

		for( n = from; n < to; ++n )
			scoreTriangle( n );

		players[player].update( 2 );
	}

	function checkState()
	{
		var n;

		for( n = trianglesLength; n--; )
			if( triangles[n].player < 0 &&
				(canScoreSmallQuad( n, activePlayer ) > -1 ||
					canScoreBigQuad( n, activePlayer ) > -1) )
				return;

		fine = true;

		var s0 = players[0].score,
			s1 = players[1].score,
			winner,
			msg,
			color;

		if( s0 > s1 )
		{
			winner = 0;
			msg = "Player 1 won!";
			color = players[0].color;
		}
		else if( s0 < s1 )
		{
			winner = 1;
			msg = "Player 1 won!";
			color = players[1].color;
		}
		else
		{
			winner = -1;
			msg = "Draw!";
			color = "#888";
		}

		if( winner > -1 )
			++players[winner].wins;

		ctx.clearRect( 0, 0, width, height );
		ctx.fillStyle = color;
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		ctx.font = Math.round( width*.05 )+"px sans-serif";
		ctx.fillText(
			msg,
			width/2,
			height/2 );
	}

	function newGame()
	{
		var n;

		for( n = trianglesLength; n--; )
			triangles[n].reset();

		for( n = 2; n--; )
		{
			players[n].score = 0;
			players[n].update( 0 );
		}

		if( (quadCols = ++quadRows) > 5 )
			quadCols = quadRows = 2;

		createTriangles();

		var layout = calcLayout( width, height );
		layoutTriangles( layout.board );

		fine = false;
	}

	function mouseMove( ev )
	{
		hover = posToTriangle( posFromEvent( ev ) );

		return true;
	}

	function mouseDown( ev )
	{
		return true;
	}

	function mouseUp( ev )
	{
		if( fine )
		{
			newGame();
			return true;
		}

		var n;

		if( (n = posToTriangle( posFromEvent( ev ) )) > -1 )
		{
			var t = triangles[n];

			if( t.player > -1 )
				return true;

			t.color = players[activePlayer].color;
			t.player = activePlayer;

			scoreSmallQuad( n, activePlayer );
			scoreBigQuad( n, activePlayer );

			activePlayer ^= 1;
		}

		checkState();

		return true;
	}

	function createPlayers()
	{
		var idx = 0;

		function Player( color, highlight )
		{
			this.index = idx++;
			this.score = 0;
			this.wins = 0;
			this.color = color;
			this.highlight = highlight;
			this.display = {};
		}

		Player.prototype.layoutDisplay = function( layout )
		{
			var c = document.createElement( "canvas" ),
				w = layout.width,
				h = layout.height,
				bigFont = Math.round( Math.min( w, h )*.5 );

			c.width = w;
			c.height = h;
			c.style.width = w+"px";
			c.style.height = h+"px";

			this.display = {
				image: c,
				context: c.getContext( "2d" ),
				left: layout.left[this.index],
				top: layout.top[this.index],
				textLeft: layout.textLeft,
				textTop: layout.textTop,
				width: w,
				height: h,
				bigFont: bigFont,
				smallFont: Math.round( bigFont*.6 ) };

			this.update( 0 );
		}

		Player.prototype.update = function( points )
		{
			var d = this.display,
				ctx = d.context,
				left = d.textLeft,
				top = d.textTop,
				w = d.width,
				h = d.height,
				bigFont = d.bigFont,
				smallFont = d.smallFont,
				xPlus = 0,
				yPlus = 0,
				tl,
				tt,
				tr,
				tb;

			ctx.clearRect( 0, 0, w, h );

			if( w > h )
			{
				var th = h/4;

				tl = 0;
				tr = h;
				tt = th;
				tb = h-th;

				xPlus = 3;
				ctx.textAlign = "start";
				ctx.textBaseline = "middle";
			}
			else
			{
				tl = 0;
				tr = w;
				tt = 0;
				tb = w/2;

				yPlus = 2;
				ctx.textAlign = "center";
				ctx.textBaseline = "alphabetic";
			}

			ctx.fillStyle = this.color;
			ctx.beginPath();
			ctx.moveTo( tl+(tr-tl)/2, tt );
			ctx.lineTo( tl, tb );
			ctx.lineTo( tr, tb );
			ctx.closePath();
			ctx.fill();

			left += xPlus*h;
			top += yPlus*w;

			ctx.font = smallFont+"px sans-serif";
			ctx.fillText(
				"score",
				left,
				top );
			left += xPlus*smallFont;
			top += yPlus*smallFont;

			ctx.font = bigFont+"px sans-serif";
			ctx.fillText(
				(this.score += points),
				left,
				top );
			left += xPlus*bigFont;
			top += yPlus*bigFont;

			ctx.font = smallFont+"px sans-serif";
			ctx.fillText(
				"wins",
				left,
				top );
			left += xPlus*smallFont;
			top += yPlus*smallFont;

			ctx.font = bigFont+"px sans-serif";
			ctx.fillText(
				this.wins,
				left,
				top );
		}

		players = [
			new Player(
				"#399ed7",
				"#0075c0" ),
			new Player(
				"#a8cd43",
				"#7ba212" )];
	}

	function layoutTriangles( layout )
	{
		var left = layout.left,
			top = layout.top,
			w = layout.width/quadCols,
			h = layout.height/quadRows,
			w2 = w/2,
			h2 = h/2,
			r,
			c,
			n = 0;

		for( r = 0; r < quadRows; ++r )
		{
			var bottom = top+h;
			var cy = top+h2;

			for( c = 0; c < quadCols; ++c )
			{
				var right = left+w;
				var cx = left+w2;

				triangles[n++].vertices = [
					left, bottom,
					left, top,
					cx, cy];

				triangles[n++].vertices = [
					left, top,
					right, top,
					cx, cy];

				triangles[n++].vertices = [
					right, top,
					right, bottom,
					cx, cy];

				triangles[n++].vertices = [
					right, bottom,
					left, bottom,
					cx, cy];

				left = right;
			}

			left = layout.left;
			top = bottom;
		}
	}

	function createTriangles()
	{
		function Triangle( color )
		{
			this.unselectedColor = color;
			this.vertices = null;

			this.reset();
		}

		Triangle.prototype.reset = function()
		{
			this.color = this.unselectedColor;
			this.scored = false;
			this.player = -1;
			this.move = null;
		}

		var l = quadCols*quadRows*4,
			n;

		triangles = [];

		for( n = 0; n < l; ++n )
			triangles[n] = new Triangle( n & 1 ?
				"#e0e0e0" :
				"#d0d0d0" );

		trianglesLength = triangles.length;
		trianglesPerRow = quadCols << 2
		trianglesMod = trianglesPerRow-2;
	}

	function resizeCanvas( c, w, h )
	{
		c.width = w;
		c.height = h;
		c.style.width = w+"px";
		c.style.height = h+"px";
	}

	function calcLayout( w, h )
	{
		var min = Math.min( w, h ),
			size = Math.round( min*.9 ),
			left = (w-size)/2,
			top = (h-size)/2,
			margin = (min-size)/2,
			player,
			playerSize = Math.round( size*.1 ),
			playerSizeMargin = playerSize+margin,
			playerSizeMargin2 = playerSizeMargin*2;

		if( w > h )
		{
			if( playerSizeMargin2+size > w )
			{
				size = w-playerSizeMargin2;
				left = (w-size)/2;
				top = (h-size)/2;
			}

			player = {
				left: [left-playerSizeMargin, left+size+margin],
				top: [top, top],
				textLeft: playerSize/2,
				textTop: 0,
				width: playerSize,
				height: size };
		}
		else
		{
			if( playerSizeMargin2+size > h )
			{
				size = h-playerSizeMargin2;
				left = (w-size)/2;
				top = (h-size)/2;
			}

			player = {
				left: [left, left],
				top: [top-playerSizeMargin, top+size+margin],
				textLeft: 0,
				textTop: playerSize/2,
				width: size,
				height: playerSize };
		}

		return {
			board: {
				left: left,
				top: top,
				width: size,
				height: size },
			player: player };
	}

	function layoutGame( w, h )
	{
		resizeCanvas( canvas, w, h );

		width = w;
		height = h;
		horizon = Math.max( w, h )*1.5;
		normalMag = Math.min( w, h )*.01;

		var layout = calcLayout( w, h );

		layoutTriangles( layout.board );

		var n;
		for( n = 2; n--; )
			players[n].layoutDisplay( layout.player );
	}

	g.resize = function( w, h )
	{
		if( !canvas )
			return;

		layoutGame( w, h );
	}

	g.start = function( w, h )
	{
		if( !(canvas = document.createElement( "canvas" )) )
			return;

		ctx = canvas.getContext( "2d" );

		createTriangles();
		createPlayers();

		layoutGame( w, h );

		document.body.appendChild( canvas );

		canvas.onmousemove = mouseMove;
		canvas.onmousedown = mouseDown;
		canvas.onmouseup = mouseUp;

		if( "ontouchstart" in document.documentElement )
		{
			canvas.ontouchmove = mouseMove;
			canvas.ontouchstart = mouseDown;
			canvas.ontouchend = mouseUp;
		}

		run();
	};
}( Game );

// shim layer with setTimeout fallback
// see http://paulirish.com/2011/requestanimationframe-for-smart-animating/
window.requestAnimFrame =
	window.requestAnimationFrame ||
	window.webkitRequestAnimationFrame ||
	window.mozRequestAnimationFrame ||
	window.oRequestAnimationFrame ||
	window.msRequestAnimationFrame ||
	function( callback, element )
	{
		window.setTimeout(
			function()
			{
				callback( new Date().getTime() );
			},
			16 );
	};

window.onresize = function()
{
	Game.resize(
		window.innerWidth,
		window.innerHeight );
}

window.onload = function()
{
	// wait 500 ms to give mobile browsers enough time to get
	// window.inner* properties right
	setTimeout(
		function()
		{
			Game.start(
				window.innerWidth,
				window.innerHeight );
		},
		500 );
};

</script>
</body>
</html>
